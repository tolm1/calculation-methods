```
max = M[0]
for(i = 1; i < N; i++){
   if(M[i] > max){
      max = M[i]  
    }
}
```
Будет N шагов, что довольно медленно 

Возьмем P = N/2 процессов 

На первом шаге мы сразу сравним все элементы массива между собой 

Дальше нам уже нужно сравнить половину чисел, 
![[Pasted image 20241006122159.png]]

Сложность будет T(N) = O(log_2 N), вычислительная стоимость C(N) = T(N)P(N) = O(N log_2 N) - дорого

С оптимизируем, хотим C = O(N), T(N) = O(log_2 N) -> P = N/(log_2 N) процессов 

Каждый процесс будет обрабатывать по n = N/P = N/N/(log_2 N) = log_2 N элементов.  

Пусть N = 16, P = 4, n = 4. Каждый раз будем убирать по 4 элемента из массива, если элементов >= 8 (P\*2) - 16, 12, 8, 4, 2

Немного про сложность O(log_2 N) - если увеличим входные данные вдовое, то количество операций увеличить всего на 1  

[[Методы вычислений]]